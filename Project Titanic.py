# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10_edIEzFZTW6taGEFMTvBuY0Fur76SL-
"""

import pandas as pd
import numpy as np

df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/ChanDarren_RaiTaran_Lab2a.csv")

Passengerid = df["PassengerId"].to_numpy()
print(Passengerid)

Survived = df["Survived"].to_numpy()
print(Survived)

Pclass = df["Pclass"].to_numpy()
print(Pclass)

Name = df["Name"].to_numpy()
print(Name)

Sex = df["Sex"].to_numpy()
print(Sex)

Age = df["Age"].to_numpy()
print(Age)

SibSp = df["SibSp"].to_numpy()
print(SibSp)

Parch = df["Parch"].to_numpy()
print(Parch)

Ticket = df["Ticket"].to_numpy()
print(Ticket)

Fare = df["Fare"].to_numpy()
print(Fare)

Cabin = df["Cabin"].to_numpy()
print(Cabin)

display(df.head())

Embarked = df["Embarked"].to_numpy()
print(Embarked )

Age_Series = df["Age"]
Fare_Series = df["Fare"]
Survived_Series = df["Survived"]

print("Age Series (first 5 values):")
print(Age_Series.head())
print("\nFare Series (first 5 values):")
print(Fare_Series.head())
print("\nSurvived Series (first 5 values):")
print(Survived_Series.head())

print("\nDataFrame Information:")
df.info()

print("\nDataFrame Descriptive Statistics:")
df.describe()



"""# Task
The plan is to handle missing values in the DataFrame. First, I will identify and display the count of missing values for each column. Then, I will impute missing 'Age' values with the mean of the 'Age' column and missing 'Embarked' values with the mode of the 'Embarked' column. For the 'Cabin' column, I will decide on an appropriate strategy (e.g., dropping or filling with 'Unknown'). Finally, I will verify that all missing values have been handled and summarize the steps taken.

## Identify Missing Values

### Subtask:
Identify and display the count of missing values for each column in the DataFrame using `isnull().sum()`.

**Reasoning**:
To identify and display the count of missing values for each column, I will use the `.isnull().sum()` method on the DataFrame `df` and print the output.
"""

print("Missing values per column:")
print(df.isnull().sum())

"""## Handle Missing 'Age' Values

### Subtask:
Impute missing values in the 'Age' column using the mean of the 'Age' column. This will fill numerical missing data with a central tendency measure.

**Reasoning**:
To impute missing values in the 'Age' column, I will first calculate the mean of the existing 'Age' values. Then, I will use this mean to fill the NaN values in the 'Age' column. Finally, I will verify that the imputation was successful by checking for any remaining missing values in the 'Age' column.
"""

mean_age = df['Age'].mean()
df['Age'].fillna(mean_age, inplace=True)
print(f"Missing values in 'Age' column after imputation: {df['Age'].isnull().sum()}")

"""**Reasoning**:
The previous code produced a `FutureWarning` due to the use of `inplace=True` with chained assignment. To address this, I will modify the line to directly assign the result of `fillna` back to the 'Age' column, which is the recommended practice for such operations and ensures the change is applied to the original DataFrame.


"""

mean_age = df['Age'].mean()
df['Age'] = df['Age'].fillna(mean_age)
print(f"Missing values in 'Age' column after imputation: {df['Age'].isnull().sum()}")

"""## Handle Missing 'Embarked' Values

### Subtask:
Impute missing values in the 'Embarked' column using the mode of the 'Embarked' column. This is appropriate for categorical data.

**Reasoning**:
To impute missing values in the 'Embarked' column, I will first calculate the mode of the column, select the first mode if there are multiple, and then fill the NaN values with this mode. Finally, I will verify the imputation.
"""

mode_embarked = df['Embarked'].mode()[0]
df['Embarked'] = df['Embarked'].fillna(mode_embarked)
print(f"Missing values in 'Embarked' column after imputation: {df['Embarked'].isnull().sum()}")

"""## Handle Missing 'Cabin' Values

### Subtask:
Address missing values in the 'Cabin' column by filling them with the string 'Unknown'. This approach is chosen because a significant portion of the data is missing, and the absence of cabin information might be a relevant category itself.

#### Instructions
1. Fill any missing values (`NaN`) in the 'Cabin' column with the string 'Unknown'. Assign the result back to the 'Cabin' column. For example: `df['Cabin'] = df['Cabin'].fillna('Unknown')`.
2. Verify that all missing values in the 'Cabin' column have been handled by printing the count of missing values for this column. For example: `print(f"Missing values in 'Cabin' column after imputation: {df['Cabin'].isnull().sum()}")`.

**Reasoning**:
To handle the missing values in the 'Cabin' column as outlined in the subtask, I will fill all NaN entries with the string 'Unknown' and then print the count of remaining missing values in that column to confirm the imputation.
"""

df['Cabin'] = df['Cabin'].fillna('Unknown')
print(f"Missing values in 'Cabin' column after imputation: {df['Cabin'].isnull().sum()}")

"""## Verify Missing Values Handled

### Subtask:
Re-run `isnull().sum()` to confirm that all missing values have been appropriately handled or addressed.

**Reasoning**:
To confirm that all missing values have been successfully handled across the DataFrame, I will re-run the `isnull().sum()` method and print the result along with a descriptive message.
"""

print("Verifying all missing values have been handled:")
print(df.isnull().sum())

"""## Final Task

### Subtask:
Summarize the steps taken to handle missing data and confirm the dataset is now clean and ready for further analysis.

## Summary:

### Data Analysis Key Findings
*   Initially, missing values were identified in three columns: 'Age' had 177 missing entries, 'Cabin' had 687 missing entries, and 'Embarked' had 2 missing entries. All other columns were complete.
*   Missing 'Age' values were successfully imputed using the mean of the 'Age' column. After this step, the 'Age' column had 0 missing values.
*   Missing 'Embarked' values were successfully imputed using the mode of the 'Embarked' column. After this step, the 'Embarked' column had 0 missing values.
*   Missing 'Cabin' values were handled by filling them with the string 'Unknown'. After this step, the 'Cabin' column had 0 missing values.
*   A final verification confirmed that all columns in the DataFrame now have 0 missing values, indicating successful handling of all identified missing data.

### Insights or Next Steps
*   The dataset is now clean and prepared for further analytical tasks, as all missing values have been systematically addressed using appropriate imputation strategies for numerical and categorical data.
*   Consider exploring the 'Unknown' category in the 'Cabin' column during further analysis, as its presence might indicate a distinct group or pattern, and evaluate its impact on other variables like 'Survived'.

## Indexing and Slicing

### Subtask: Retrieve details of specific passengers using `.loc[]` and `.iloc[]` and extract columns such as 'Age', 'Fare', and 'Survived'.

**Reasoning**:
To retrieve details using `.loc[]`, I will select rows by index labels (e.g., specific PassengerIds) and specify the desired columns ('Age', 'Fare', 'Survived').
To retrieve details using `.iloc[]`, I will select rows by integer positions and specify the integer positions of the desired columns. Both methods are crucial for flexible data access.
"""

specific_passengers_loc = df.loc[[0, 2, 4], ['Age', 'Fare', 'Survived']]
print("Details for PassengerId 1, 3, and 5 using .loc[] (indexed from 0):")
print(specific_passengers_loc)

specific_passengers_iloc = df.iloc[[0, 2, 4], [5, 9, 1]]
print("\nDetails for the 1st, 3rd, and 5th passengers using .iloc[]:")
print(specific_passengers_iloc)

"""# Task
Rename the 'Sex' column to 'Gender' in the DataFrame, then create a pivot table to analyze the mean survival rate by 'Gender' and 'Pclass', and finally, summarize these operations and interpret the findings from the pivot table.

## Rename 'Sex' Column to 'Gender'

### Subtask:
Rename the 'Sex' column in the DataFrame to 'Gender' to improve clarity and consistency in the dataset.

**Reasoning**:
To rename the 'Sex' column to 'Gender' and apply the change directly to the DataFrame, I will use the `.rename()` method with `inplace=True`. Then, I will print the DataFrame's columns to verify the change.
"""

df.rename(columns={'Sex': 'Gender'}, inplace=True)
print(df.columns)

"""**Reasoning**:
Now that the 'Sex' column has been successfully renamed to 'Gender', the next step is to create a pivot table to analyze the mean survival rate by 'Gender' and 'Pclass', as outlined in the main task. This will provide insights into how gender and passenger class influenced survival.


"""

pivot_table = df.pivot_table(values='Survived', index='Gender', columns='Pclass', aggfunc='mean')
print("\nMean Survival Rate by Gender and Pclass:")
print(pivot_table)

"""### Summary and Interpretation of Findings

**Operations Performed:**
1.  The 'Sex' column was successfully renamed to 'Gender' for better clarity and consistency in the dataset.
2.  A pivot table was created to analyze the mean survival rate, grouping the data by 'Gender' as the index and 'Pclass' as columns.

**Interpretation of Pivot Table Findings:**
*   **Gender Impact:** The survival rate for females across all passenger classes is significantly higher than for males. For instance, in Pclass 1, 96.8% of females survived compared to 36.9% of males. This highlights a strong "women and children first" survival bias.
*   **Pclass Impact:** Survival rates generally decrease with lower passenger classes for both genders. Passengers in Pclass 1 had the highest survival rates, followed by Pclass 2, and then Pclass 3. This indicates that socio-economic status, as represented by Pclass, played a crucial role in survival.
*   **Combined Effect:** The highest survival rate is observed for females in Pclass 1 (96.8%), while the lowest is for males in Pclass 3 (13.5%). This clearly shows that being a female in a higher passenger class drastically increased one's chances of survival, whereas being a male in a lower passenger class severely decreased it.

## Final Task

### Subtask:
Summarize the renaming and reshaping operations performed and briefly interpret the results from the pivot table.

## Summary:

### Q&A
The 'Sex' column was renamed to 'Gender' for clarity. A pivot table was then created to reshape the data, analyzing the mean survival rate grouped by 'Gender' as the index and 'Pclass' as columns. The interpretation of the pivot table revealed a significant disparity in survival rates based on both gender and passenger class, with females and higher classes having much greater survival chances.

### Data Analysis Key Findings
*   The 'Sex' column was successfully renamed to 'Gender' for improved clarity and consistency in the dataset.
*   A pivot table was generated, revealing that females had a significantly higher mean survival rate compared to males across all passenger classes. For instance, in Pclass 1, 96.8% of females survived versus 36.9% of males.
*   Survival rates generally decreased with lower passenger classes (higher Pclass number) for both genders, indicating that socio-economic status played a crucial role.
*   The highest survival rate was observed for females in Pclass 1 (96.8%), while the lowest was for males in Pclass 3 (13.5%).

### Insights or Next Steps
*   The stark difference in survival rates highlights a strong "women and children first" bias and the influence of socio-economic status (represented by Pclass) on survival outcomes.
*   Further analysis could involve exploring the interaction effects of 'Age' with 'Gender' and 'Pclass' to identify more specific demographics that were most vulnerable or resilient.

# Task
Filter the `df` DataFrame to include passengers older than 30, passengers with a fare greater than 50, and female survivors. Then, sort the DataFrame by 'Fare' in descending order, by 'Age' in ascending order, and by 'Survived' status (showing survivors first). Finally, summarize these filtering and sorting operations and their results.

## Filter Passengers by Age

### Subtask:
Filter the DataFrame to include only passengers with 'Age' greater than 30.

**Reasoning**:
To filter the DataFrame, I will use boolean indexing on the 'Age' column to select rows where 'Age' is greater than 30 and store the result in a new DataFrame named `df_filtered_age`.
"""

df_filtered_age = df[df['Age'] > 30]
print("DataFrame filtered for Age > 30 (first 5 rows):")
print(df_filtered_age.head())

"""**Reasoning**:
Now that the DataFrame has been filtered by age, I will further filter it to include only passengers with 'Fare' greater than 50, storing the result in a new DataFrame named `df_filtered_fare`.


"""

df_filtered_fare = df_filtered_age[df_filtered_age['Fare'] > 50]
print("DataFrame filtered for Fare > 50 (first 5 rows):")
print(df_filtered_fare.head())

"""**Reasoning**:
Now that the DataFrame has been filtered by age and fare, I will apply the final filter to include only female survivors, storing the result in a new DataFrame named `df_female_survivors`.


"""

df_female_survivors = df_filtered_fare[(df_filtered_fare['Gender'] == 'female') & (df_filtered_fare['Survived'] == 1)]
print("DataFrame filtered for female survivors (Age > 30, Fare > 50) (first 5 rows):")
print(df_female_survivors.head())

"""## Sort the DataFrame

### Subtask:
Sort the `df_female_survivors` DataFrame by 'Fare' in descending order, then by 'Age' in ascending order, and finally by 'Survived' status (showing survivors first).

**Reasoning**:
To sort the `df_female_survivors` DataFrame as requested, I will use the `sort_values()` method, specifying 'Fare' in descending order, 'Age' in ascending order, and 'Survived' in descending order to prioritize survivors.
"""

df_sorted = df_female_survivors.sort_values(by=['Fare', 'Age', 'Survived'], ascending=[False, True, False])
print("DataFrame sorted by Fare (desc), Age (asc), and Survived (desc) (first 5 rows):")
print(df_sorted.head())

"""### Summary of Filtering and Sorting Operations

**Operations Performed:**
1.  **Filtering by Age:** The initial `df` DataFrame was filtered to select only passengers older than 30, resulting in `df_filtered_age`.
2.  **Filtering by Fare:** `df_filtered_age` was further filtered to include only passengers with a 'Fare' greater than 50, creating `df_filtered_fare`.
3.  **Filtering by Gender and Survival:** `df_filtered_fare` was then filtered to isolate female survivors, resulting in `df_female_survivors`.
4.  **Sorting:** The `df_female_survivors` DataFrame was sorted by 'Fare' in descending order, then by 'Age' in ascending order, and finally by 'Survived' status in descending order (to show survivors first).

**Interpretation of Results:**
The final `df_sorted` DataFrame represents a highly specific subset of passengers: female survivors over 30 years old who paid more than 50 for their ticket. The sorting highlights that within this group, those who paid the highest fares appear first. This ordered subset can be useful for examining characteristics of high-paying, older female survivors, potentially revealing patterns related to higher class travel and its correlation with survival outcomes.

## Summary:

### Data Analysis Key Findings

*   The DataFrame was sequentially filtered to identify a specific subset of passengers:
    *   First, passengers older than 30 were selected.
    *   From this group, passengers who paid a fare greater than \$50 were identified.
    *   Finally, female survivors were isolated from the previously filtered group.
*   The resulting DataFrame, containing female survivors older than 30 with a fare greater than \$50, was then sorted.
*   The sorting order prioritized passengers by 'Fare' in descending order, followed by 'Age' in ascending order, and finally by 'Survived' status in descending order (showing survivors first).
*   The `df_sorted` DataFrame represents a highly specific subset of passengers: female survivors over 30 years old who paid more than \$50 for their ticket, with the highest-paying individuals appearing first.

### Insights or Next Steps

*   This specifically filtered and sorted dataset can be utilized to examine the characteristics of high-paying, older female survivors, potentially revealing patterns related to higher class travel and its correlation with survival outcomes.
*   Further analysis could involve exploring other attributes of this specific group, such as their embarkation point, cabin class, or family size, to uncover additional commonalities among these survivors.

# Task
Calculate the mean survival rate by gender, the average age by passenger class, and the total survival count by embarked location using the `df` DataFrame, and then summarize and interpret the key findings from each analysis.

## Survival Rate by Gender

### Subtask:
Calculate the mean survival rate for each 'Gender' using the `groupby()` method on the 'Gender' column and the 'Survived' column.

**Reasoning**:
To calculate the mean survival rate for each 'Gender', I will group the DataFrame by 'Gender' and then compute the mean of the 'Survived' column.
"""

survival_rate_by_gender = df.groupby('Gender')['Survived'].mean()
print("Mean Survival Rate by Gender:")
print(survival_rate_by_gender)

"""## Average Age by Passenger Class

### Subtask:
Calculate the average age for each 'Pclass' using the `groupby()` method on the 'Pclass' column and the 'Age' column.

#### Instructions
1. Group the DataFrame `df` by the 'Pclass' column.
2. Calculate the mean of the 'Age' column for each passenger class.
3. Print the result with a descriptive message, for example, 'Average Age by Passenger Class:'.

**Reasoning**:
To calculate the average age for each passenger class, I will group the DataFrame by 'Pclass' and then compute the mean of the 'Age' column.
"""

average_age_by_pclass = df.groupby('Pclass')['Age'].mean()
print("Average Age by Passenger Class:")
print(average_age_by_pclass)

"""```markdown
## Total Survival Count by Embarked Location

### Subtask:
Calculate the total survival count for each 'Embarked' location. Use the `groupby()` method on the 'Embarked' column and sum the 'Survived' column.

#### Instructions
1. Group the DataFrame `df` by the 'Embarked' column.
2. Calculate the sum of the 'Survived' column for each embarkation location.
3. Print the result with a descriptive message, for example, 'Total Survival Count by Embarked Location:'.
```

## Total Survival Count by Embarked Location

### Subtask:
Calculate the total survival count for each 'Embarked' location. Use the `groupby()` method on the 'Embarked' column and sum the 'Survived' column.

#### Instructions
1. Group the DataFrame `df` by the 'Embarked' column.
2. Calculate the sum of the 'Survived' column for each embarkation location.
3. Print the result with a descriptive message, for example, 'Total Survival Count by Embarked Location:'.

**Reasoning**:
To calculate the total survival count for each 'Embarked' location, I will group the DataFrame by 'Embarked' and then compute the sum of the 'Survived' column, as per the subtask instructions.
"""

survival_count_by_embarked = df.groupby('Embarked')['Survived'].sum()
print("Total Survival Count by Embarked Location:")
print(survival_count_by_embarked)

"""### Summary and Interpretation of Findings

**1. Mean Survival Rate by Gender:**
*   **Finding:** The mean survival rate for females was approximately 74.2%, while for males it was about 18.9%.
*   **Interpretation:** This clearly indicates a significant disparity in survival based on gender, with females having a much higher chance of survival. This aligns with the 'women and children first' protocol often associated with such maritime disasters.

**2. Average Age by Passenger Class:**
*   **Finding:** The average age for Pclass 1 was around 37.05 years, for Pclass 2 was 29.87 years, and for Pclass 3 was 26.40 years.
*   **Interpretation:** This shows a trend where passengers in higher classes (Pclass 1) tended to be older on average compared to those in lower classes (Pclass 3). This could imply differences in socio-economic status or life stage among the passenger classes.

**3. Total Survival Count by Embarked Location:**
*   **Finding:** Total survival counts were: Cherbourg (C) - 93, Queenstown (Q) - 30, Southampton (S) - 219.
*   **Interpretation:** Southampton (S) had the highest number of survivors, which is expected as it was the primary embarkation port and likely had the most passengers. Cherbourg (C) had a moderate number of survivors, while Queenstown (Q) had the fewest. Further analysis would be needed to determine if the survival *rate* (proportion) varied significantly by embarkation port, considering the total number of passengers from each port.

## Final Task

### Subtask:
Summarize the grouping and aggregation operations performed and interpret the key findings from each analysis.

## Summary:

### Q&A
The analysis revealed that female passengers had a significantly higher survival rate (approximately 74.2%) compared to male passengers (approximately 18.9%). The average age of passengers decreased with lower passenger classes, with Pclass 1 having an average age of about 37.05 years, Pclass 2 about 29.87 years, and Pclass 3 about 26.40 years. For embarked locations, Southampton (S) had the highest number of survivors (219), followed by Cherbourg (C) with 93, and Queenstown (Q) with 30 survivors.

### Data Analysis Key Findings
*   **Survival Rate by Gender:** Female passengers had a much higher mean survival rate of approximately 74.2% compared to male passengers, who had a survival rate of about 18.9%.
*   **Average Age by Passenger Class:** The average age of passengers varied by class: Pclass 1 passengers were the oldest on average at 37.05 years, Pclass 2 passengers averaged 29.87 years, and Pclass 3 passengers were the youngest on average at 26.40 years.
*   **Total Survival Count by Embarked Location:** Southampton (S) recorded the highest number of survivors with 219, followed by Cherbourg (C) with 93 survivors, and Queenstown (Q) with 30 survivors.

### Insights or Next Steps
*   The stark difference in survival rates between genders suggests the 'women and children first' protocol was largely followed.
*   Further analysis could involve calculating the survival *rate* (proportion of survivors to total passengers) for each embarked location to understand if the survival probability varied by port, rather than just the absolute count.

# Task
The task is to create an additional small DataFrame containing sample data that can be linked with the existing `df`. Then, demonstrate `pd.merge()` to combine `df` with the new DataFrame based on common columns, `DataFrame.join()` to combine them based on indexes or a common column, and `pd.concat()` to stack or append them row-wise or column-wise. Finally, summarize the differences between `merge()`, `join()`, and `concat()` and the outcomes of each demonstration.

## Create Additional DataFrame

### Subtask:
Create an additional small DataFrame to be used for demonstrating merge, join, and concatenate operations. This DataFrame will contain sample data that can be linked with the existing `df`.

**Reasoning**:
To create the additional DataFrame as requested, I will define a dictionary with 'PassengerId' and 'TicketCategory' values, ensuring some passenger IDs overlap with the main DataFrame and some are new, then convert it to a pandas DataFrame and display its head.
"""

data = {
    'PassengerId': [1, 2, 892, 4, 893, 6, 894, 895],
    'TicketCategory': ['Standard', 'Premium', 'Economy', 'Premium', 'Standard', 'Economy', 'Standard', 'Premium']
}
df_additional = pd.DataFrame(data)

print("Additional DataFrame (df_additional):")
print(df_additional.head())

"""## Demonstrate merge()

### Subtask:
Use `pd.merge()` to combine the main `df` with the newly created DataFrame.

**Reasoning**:
To combine the main DataFrame `df` with `df_additional` using `pd.merge()`, I will perform an inner merge on the 'PassengerId' column, store the result in `df_merged`, and then display its head to verify the operation.
"""

df_merged = pd.merge(df, df_additional, on='PassengerId', how='inner')
print("Merged DataFrame (df_merged - first 5 rows):")
print(df_merged.head())

"""## Demonstrate join()

### Subtask:
Use `DataFrame.join()` to combine the main `df` with `df_additional`.

`DataFrame.join()` defaults to joining on indexes. To join on a column, one of the DataFrames needs to have that column set as its index. Since `df_additional` has 'PassengerId' as a regular column, we will set 'PassengerId' as the index for `df_additional` before performing the join. For `df`, it already has a default integer index, so we will use its 'PassengerId' column by setting it as the index before joining.

#### Instructions
1. Set 'PassengerId' as the index for `df_additional`.
2. Set 'PassengerId' as the index for `df`.
3. Perform a left join of `df` (with 'PassengerId' as index) and `df_additional` (with 'PassengerId' as index) using `df.join(df_additional, how='left', rsuffix='_additional')`. The `rsuffix` is used to differentiate columns with the same name if they exist in both DataFrames, though in this case, only 'TicketCategory' is added.
4. Store the result in a new DataFrame named `df_joined`.
5. Print the first few rows of `df_joined` using `.head()` to inspect the joined DataFrame.

**Reasoning**:
To demonstrate `DataFrame.join()`, I will first temporarily set 'PassengerId' as the index for both `df` and `df_additional`, perform a left join, and then reset the index for `df` to its original state to avoid modifying it permanently for subsequent tasks.
"""

df_temp = df.set_index('PassengerId')
df_additional_indexed = df_additional.set_index('PassengerId')
df_joined = df_temp.join(df_additional_indexed, how='left', rsuffix='_additional')

print("Joined DataFrame (df_joined - first 5 rows):")
print(df_joined.head())

"""## Demonstrate concat()

### Subtask:
Use `pd.concat()` to combine the main `df` with `df_additional`, demonstrating both row-wise and column-wise concatenation.

#### Instructions
1.  **Row-wise Concatenation**: Stack `df` and `df_additional` vertically. Since `df_additional` has fewer columns and different column names than `df`, this will result in many `NaN` values for non-matching columns.
    *   Store the result in a new DataFrame named `df_concat_rows`.
    *   Print the first few rows and the shape of `df_concat_rows` to inspect the concatenated DataFrame.
2.  **Column-wise Concatenation**: Concatenate `df` and `df_additional` horizontally. This will add `df_additional`'s columns to `df`.
    *   Before concatenation, reset the index of `df_additional` if it was set to 'PassengerId' in the previous step, or ensure both DataFrames have a compatible index for horizontal concatenation. For simplicity, we will assume `df_additional` still has its default integer index and `df` has its default integer index.
    *   Store the result in a new DataFrame named `df_concat_cols`.
    *   Print the first few rows and the shape of `df_concat_cols` to inspect the concatenated DataFrame.

**Reasoning**:
To demonstrate `pd.concat()`, I will first perform row-wise concatenation of `df` and `df_additional`, and then column-wise concatenation of the same two DataFrames, printing the head and shape of each resulting DataFrame to inspect the results.
"""

print("1. Row-wise Concatenation (df_concat_rows):")
df_concat_rows = pd.concat([df, df_additional], ignore_index=True)
print(df_concat_rows.head())
print(f"Shape of df_concat_rows: {df_concat_rows.shape}")

print("\n2. Column-wise Concatenation (df_concat_cols):")
df_concat_cols = pd.concat([df, df_additional], axis=1)
print(df_concat_cols.head())
print(f"Shape of df_concat_cols: {df_concat_cols.shape}")

"""## Summary of Merge, Join, and Concatenate Operations

**1. `pd.merge()`**
*   **Purpose**: Combines DataFrames based on values in common columns (or indices).
*   **Demonstration Outcome**: We performed an `inner` merge on the 'PassengerId' column between `df` and `df_additional`. The resulting `df_merged` DataFrame contains only the rows where 'PassengerId' existed in both original DataFrames, effectively adding the 'TicketCategory' to matching passengers.
*   **Key Difference**: `merge()` is best for combining data based on shared key columns, similar to SQL joins, and offers various types of joins (inner, outer, left, right).

**2. `DataFrame.join()`**
*   **Purpose**: Combines DataFrames primarily based on their indices. It can also join on a column by setting that column as the index first.
*   **Demonstration Outcome**: We temporarily set 'PassengerId' as the index for both `df` and `df_additional` and performed a `left` join. The `df_joined` DataFrame contains all rows from the original `df` (our left DataFrame) and the 'TicketCategory' from `df_additional` where 'PassengerId' matched. Non-matching PassengerIds from `df_additional` result in `NaN` in the 'TicketCategory' column.
*   **Key Difference**: `join()` is a convenience method for combining DataFrames that have a common index or when one DataFrame's index matches a column in another.

**3. `pd.concat()`**
*   **Purpose**: Stacks or appends DataFrames either vertically (row-wise) or horizontally (column-wise).
*   **Demonstration Outcome**:
    *   **Row-wise (`df_concat_rows`)**: We concatenated `df` and `df_additional` vertically. The result contains all rows from both DataFrames. Columns unique to one DataFrame (e.g., 'TicketCategory' in `df_additional` or most columns in `df`) have `NaN` values where data from the other DataFrame is missing. The shape indicated an increased number of rows (891 + 8 = 899).
    *   **Column-wise (`df_concat_cols`)**: We concatenated `df` and `df_additional` horizontally. The result contains all columns from both DataFrames side-by-side. Since `df_additional` has fewer rows than `df`, the extra rows in `df` have `NaN` values for the columns from `df_additional`.
*   **Key Difference**: `concat()` is for

## Summary of Merge, Join, and Concatenate Operations

**1. `pd.merge()`**
*   **Purpose**: Combines DataFrames based on values in common columns (or indices).
*   **Demonstration Outcome**: We performed an `inner` merge on the 'PassengerId' column between `df` and `df_additional`. The resulting `df_merged` DataFrame contains only the rows where 'PassengerId' existed in both original DataFrames, effectively adding the 'TicketCategory' to matching passengers.
*   **Key Difference**: `merge()` is best for combining data based on shared key columns, similar to SQL joins, and offers various types of joins (inner, outer, left, right).

**2. `DataFrame.join()`**
*   **Purpose**: Combines DataFrames primarily based on their indices. It can also join on a column by setting that column as the index first.
*   **Demonstration Outcome**: We temporarily set 'PassengerId' as the index for both `df` and `df_additional` and performed a `left` join. The `df_joined` DataFrame contains all rows from the original `df` (our left DataFrame) and the 'TicketCategory' from `df_additional` where 'PassengerId' matched. Non-matching PassengerIds from `df_additional` result in `NaN` in the 'TicketCategory' column.
*   **Key Difference**: `join()` is a convenience method for combining DataFrames that have a common index or when one DataFrame's index matches a column in another.

**3. `pd.concat()`**
*   **Purpose**: Stacks or appends DataFrames either vertically (row-wise) or horizontally (column-wise).
*   **Demonstration Outcome**:
    *   **Row-wise (`df_concat_rows`)**: We concatenated `df` and `df_additional` vertically. The result contains all rows from both DataFrames. Columns unique to one DataFrame (e.g., 'TicketCategory' in `df_additional` or most columns in `df`) have `NaN` values where data from the other DataFrame is missing. The shape indicated an increased number of rows (891 + 8 = 899).
    *   **Column-wise (`df_concat_cols`)**: We concatenated `df` and `df_additional` horizontally. The result contains all columns from both DataFrames side-by-side. Since `df_additional` has fewer rows than `df`, the extra rows in `df` have `NaN` values for the columns from `df_additional`.
*   **Key Difference**: `concat()` is primarily used for stacking DataFrames along an axis, either by rows (axis=0) or columns (axis=1), and is flexible with non-matching columns/rows by filling with NaN. It does not look for common values to merge upon, but rather aligns based on index or position.

## Final Task

### Subtask:
Summarize the merging, joining, and concatenation operations performed, explaining the differences between them and the outcomes of each demonstration.

## Summary:

### Data Analysis Key Findings

*   **`pd.merge()`** was used for an inner join on the 'PassengerId' column, effectively combining `df` and `df_additional`. The resulting `df_merged` DataFrame contained only rows where 'PassengerId' existed in both original DataFrames, augmenting them with the 'TicketCategory' from `df_additional`.
*   **`DataFrame.join()`** required setting 'PassengerId' as the index for both DataFrames (`df` and `df_additional`) before performing a left join. The `df_joined` DataFrame retained all rows from the original `df`, adding 'TicketCategory' where 'PassengerId' indices matched. For `PassengerId`s present in `df` but not in `df_additional`, the 'TicketCategory' column was filled with `NaN` values.
*   **`pd.concat()`** was demonstrated for both row-wise and column-wise concatenations:
    *   **Row-wise concatenation** resulted in `df_concat_rows` with `899` rows (the sum of rows from `df` (891) and `df_additional` (8)). Columns not present in one of the original DataFrames were filled with `NaN` for the corresponding rows.
    *   **Column-wise concatenation** resulted in `df_concat_cols` with `891` rows and `14` columns. Columns from `df_additional` were appended horizontally. Since `df_additional` had fewer rows than `df`, the columns from `df_additional` showed `NaN` for rows beyond its original length. This method aligned based on the default integer index, leading to duplicate columns like 'PassengerId' if both DataFrames contained them.

### Insights or Next Steps

*   `pd.merge()` is ideal for combining DataFrames based on common values in specific columns, similar to SQL joins, offering precise control over how data is combined (e.g., inner, outer, left, right).
*   `DataFrame.join()` is a convenient method for index-based combinations, but if joining on a column, that column must first be set as the index in one or both DataFrames.
*   `pd.concat()` is best suited for stacking DataFrames (row-wise or column-wise) when their structures are similar or when the goal is to append data, rather than merging based on matching values. It's crucial to manage indices carefully to avoid unintended alignment or `NaN` values, especially during column-wise concatenation.

# Task
Calculate the average age of passengers who survived and those who did not survive, determine the highest and lowest fare paid by any passenger, and calculate the overall survival percentage of passengers in the dataset.

## Calculate Average Age of Survivors vs. Non-Survivors

### Subtask:
Calculate the average age for passengers who survived and for those who did not survive, using the 'Age' and 'Survived' columns.

**Reasoning**:
To calculate the average age for survivors and non-survivors, I will group the DataFrame by the 'Survived' column and then compute the mean of the 'Age' column for each group, as per the instructions.
"""

average_age_by_survival = df.groupby('Survived')['Age'].mean()
print("Average Age by Survival Status:")
print(average_age_by_survival)

"""**Reasoning**:
To determine the highest and lowest fare paid by any passenger, I will use the `.max()` and `.min()` methods on the 'Fare' column of the DataFrame.


"""

highest_fare = df['Fare'].max()
lowest_fare = df['Fare'].min()
print(f"Highest Fare Paid: {highest_fare}")
print(f"Lowest Fare Paid: {lowest_fare}")

"""**Reasoning**:
To calculate the overall survival percentage, I will count the number of survivors, divide it by the total number of passengers, and multiply by 100 to express it as a percentage.


"""

overall_survival_percentage = (df['Survived'].sum() / len(df)) * 100
print(f"Overall Survival Percentage: {overall_survival_percentage:.2f}%")

"""## Identify Patterns Affecting Survival

### Subtask:
Based on the calculated metrics and previous analyses (e.g., pivot tables on gender and Pclass), identify and describe patterns or factors that appear to affect survival rates.

## Identifying Patterns Affecting Survival

Based on the calculated metrics and previous analyses, several patterns and factors significantly affected survival rates:

### Key Factors Influencing Survival:

1.  **Gender**: This was the most prominent factor. The mean survival rate for females (approximately 74.2%) was overwhelmingly higher than for males (approximately 18.9%). The pivot table further emphasized this, showing that female survival rates were consistently high across all passenger classes (e.g., 96.8% in Pclass 1, 92.1% in Pclass 2, 50% in Pclass 3), while male survival rates were much lower.

2.  **Passenger Class (Pclass)**: Socio-economic status, as indicated by Pclass, played a crucial role. Survival rates generally decreased with lower passenger classes for both genders. Pclass 1 passengers had the highest survival rates, followed by Pclass 2, and then Pclass 3. This suggests that passengers in higher classes had better access to lifeboats or were prioritized during the evacuation.

3.  **Age**: The average age varied by survival status, with non-survivors having a slightly higher average age (30.42 years) than survivors (28.55 years). Additionally, average age decreased with lower passenger classes (Pclass 1: 37.05 years, Pclass 2: 29.87 years, Pclass 3: 26.40 years). While the difference in average age between survivors and non-survivors is not as stark as gender or Pclass, it hints that younger individuals or those in certain age brackets might have had a marginally better chance of survival, potentially aligning with the 'women and children first' principle.

4.  **Fare**: Fare often correlates with passenger class. The highest fare paid was 512.33, and the lowest was 0.0. Passengers who paid higher fares were typically in Pclass 1, which had the highest survival rates. This indirectly reinforces the importance of Pclass as a survival factor, as those who could afford more expensive tickets (and thus higher classes) had a better chance of survival.

5.  **Embarked Location**: Southampton (S) had the highest total number of survivors (219), followed by Cherbourg (C) with 93, and Queenstown (Q) with 30. While these are absolute counts and don't directly give survival rates (which would require total passengers from each port), the distribution shows that a significant portion of survivors embarked from Southampton, which was the main departure port. To fully assess the impact of embarkation, survival rates per port would be more informative.

### Overall Patterns:

*   The **"women and children first"** principle appears to have been strongly enforced, as evidenced by the significantly higher survival rates for females across all classes.
*   **Socio-economic status**, represented by Pclass, was a critical determinant, with higher classes enjoying much greater survival chances.
*   Age had a subtler influence, potentially intertwined with gender and class.
*   Fare implicitly supports the Pclass correlation with survival.

In summary, **gender and passenger class** were the most influential factors determining survival on the Titanic, with age and fare playing supporting roles, and embarkation location contributing to the overall distribution of survivors.

## Final Task

### Subtask:
Summarize all calculations and insights derived from the analysis, including patterns affecting survival.

## Summary:

### Q&A
*   **What was the average age of passengers who survived and those who did not survive?**
    The average age for passengers who survived was approximately 28.55 years, while for those who did not survive, it was approximately 30.42 years.
*   **What was the highest and lowest fare paid by any passenger?**
    The highest fare paid by a passenger was 512.33, and the lowest fare paid was 0.0.
*   **What was the overall survival percentage of passengers in the dataset?**
    The overall survival percentage of passengers in the dataset was 38.38%.

### Data Analysis Key Findings
*   **Gender was the most significant factor affecting survival:** Females had a remarkably higher mean survival rate (approximately 74.2%) compared to males (approximately 18.9%). This pattern was consistent across all passenger classes.
*   **Passenger Class (Pclass) heavily influenced survival:** Survival rates generally decreased with lower passenger classes. Pclass 1 passengers had the highest survival rates, followed by Pclass 2, and then Pclass 3, indicating the importance of socio-economic status.
*   **Age showed a subtle correlation with survival:** Non-survivors had a slightly higher average age (30.42 years) than survivors (28.55 years).
*   **Fare indirectly correlated with survival through Pclass:** Higher fares were typically associated with Pclass 1, which had the best survival rates, reinforcing the impact of Pclass.
*   **The "women and children first" principle was strongly supported by the data**, as evidenced by the high survival rates among females across all classes.

### Insights or Next Steps
*   Further analysis could involve examining specific age ranges or cohorts (e.g., children vs. adults) to understand the nuances of age's impact on survival.
*   To fully assess the impact of the embarked location, calculate and compare the survival rates for each port rather than just absolute survivor counts.
"""